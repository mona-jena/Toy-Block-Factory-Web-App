---
kind: "Template"
apiVersion: "v1"
metadata:
  name: "Deployment"
  annotations:
    description: "Kubernetes Deployment Template"
labels:
  template: "Deployment"
objects:
  
- apiVersion: apps/v1
  kind: Deployment       #how many pods to run, which app to run
  metadata:
    name: "mona-deployment"
    namespace: "fma"
  spec:
    replicas: 2
    selector:
      matchLabels:
        app: "mona"
    template:
      metadata:
        labels:
          app: "mona"
          repo: "mona-app"
      spec:
        containers:               # docker run 
          - image: "138666658526.dkr.ecr.ap-southeast-2.amazonaws.com/mona-app:$(imagetag)"  #ecr address of my image --> buildkite builds the images and pushes it to ecr
            name: mona-tbf
            env:
              - name: MONA_PORT   #variable to refer locally on app
                valueFrom:
                  secretKeyRef:
                    key: port     
                    name: "mona-port"
            ports:
              - containerPort: 3000
       

# This is an example of a service - a logical grouping of pods - so we can access all worker nodes even if they get updated

- apiVersion: v1
  kind: Service             # the 2 replicas (puts it one address) and just sends the request to a worker inside the cluster - picks a pod and sends the traffic to that pod
  metadata:
    name: "mona-service"
    namespace: "fma"
    labels:
      app: "mona"
      repo: "mona-app"
    annotations:
      prometheus.io/scrape: "true"
  spec:
    ports:
      - port: 80            # standard port for http / k8s is listening on this port and directs traffic to port 3000
        targetPort: 3000    # equivalent to postman
    selector:
      app: "mona" 


# This is an example of an ingress - a way to forward traffic to
# your services and provide SSL termination.

- apiVersion: networking.k8s.io/v1beta1
  kind: Ingress             #forward traffic from outside world into a service so users can talk to it--> sends the request to the service to talk to our app --> serv then picks one of the pods to send traffic there
  metadata:
    name: "mona-ingress"
    namespace: "fma"
    labels:
      app: "mona"
      repo: "mona-app"
    annotations:
      # This annotation will trigger the cluster to provision a TLS certificate which will
      # be stored in the specified secretName below.
      # NOTE: The secret will be:
      # - CREATED if it doesn't exist
      #       OR
      # - UPDATED if it already exists (ie. the existing certificate in the secret WILL BE OVERWRITTEN!!!)
      "kubernetes.io/tls-acme": "true"
  spec:
    rules:
      - host: "mona.svc.platform.myobdev.com"
        http:
          paths: 
            - backend:
                serviceName: "mona-service"     #so it can route to the service defined above 
                servicePort: 80                 # send traffic to port 80
              path: /
    tls:                  #gives certificate given by https
      - hosts:
          - "mona.svc.platform.myobdev.com"
        # WARNING: DO NOT use the same secret for more than one ingress
        # to ensure misconfiguration of one ingress does not affect any other ingresses
        secretName: "mona-tls"



- apiVersion: autoscaling/v2beta1
  kind: HorizontalPodAutoscaler
  metadata:
    name: "mona-autoscaler"
    namespace: "fma"
    labels:
      app: "mona"
      repo: "mona-app"
  spec:
    scaleTargetRef:
      # reference the deployment that this HPA will scale up and down
      apiVersion: apps/v1
      kind: Deployment
      name: "mona-deployment"
    # make sure this is at least 3, as that is the minimum replicas Managed Infrastructure team recommend to be running for an app
    minReplicas: 2
    maxReplicas: 5
    metrics:
      - type: External
        external:
          # this is the Metric Name from the table above
          metricName: jupiter_http_requests_per_second
          # this says that if the average number of requests per second over the last 5 minutes is greater than 10, then scale up
          targetAverageValue: 10
          metricSelector:
            matchLabels:
              # the key here is the Metric Selector from the table above and the value is the name of your Ingress you want to scale against
              ingress: mona-ingress
            

parameters:
  - name : "imagetag"
    parameterType : "string"
    required: true